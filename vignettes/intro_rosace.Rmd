---
title: "Introduction to rosace"
author: "Jingyou Rao"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to rosace}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo=FALSE, results="hide"}
knitr::opts_chunk$set(tidy = FALSE, cache = FALSE, 
                      dev = "png", dpi=300, fig.align="center", out.width = "100%",
                      fig.width=6, fig.height = 4,
                      message = FALSE, error = FALSE, warning = TRUE)
```	

## Installation

To install `rosace` start R and first install devtools by typing:

```{r eval=FALSE}
if (!requireNamespace("devtools", quietly = TRUE)) {
  install.packages("devtools")
}
```

and install `rosace` by typing:

```{r eval=FALSE}
devtools::install_github("pimentellab/rosace")
```

If you have cloned the git repository locally, navigate to the `rosace` folder and type:

```{r eval=FALSE}
devtools::install(".") 
```

Next load `rosace` with:

```{r}
library("rosace")
```

## Example

#### Read Count Data

To explain how to use `rosace` we provide an example based on the OCT1 drug cytotoxicity screen (https://www.biorxiv.org/content/10.1101/2023.06.06.543963v1.full). 

The screen has three replicates. The count matrix is stored in "data/oct1.rda".

```{r}
data("oct1")
key <- "1SM73"
type <- "growth"
```

#### Create Rosace Object

First, load the count file into the Assay object. 
Each replicate in the experiment will form an Assay object and will share the same "key" (1SM73).

```{r}
assay1 <- CreateAssayObject(counts = as.matrix(oct1_rep1[2:ncol(oct1_rep1)]),
                            var.names = oct1_rep1$hgvs,
                            key = key, rep = 1, type = type)
assay2 <- CreateAssayObject(counts = as.matrix(oct1_rep2[2:ncol(oct1_rep2)]),
                            var.names = oct1_rep2$hgvs,
                            key = key, rep = 2, type = type)
assay3 <- CreateAssayObject(counts = as.matrix(oct1_rep3[2:ncol(oct1_rep3)]),
                            var.names = oct1_rep3$hgvs,
                            key = key, rep = 3, type = type)
```

Next create Rosace object by adding three Assay objects together.

```{r}
rosace <- CreateRosaceObject(object = assay1)
rosace <- AddAssayData(object = rosace, assay = assay2)
rosace <- AddAssayData(object = rosace, assay = assay3)
GetAssayName(rosace)
```

#### Preprocessing

'CreateAssayObject' calls function 'FilterData' to filter the variants with more than 'na.rmax'% of NAs by default. But we might want to filter more variants later.

```{r}
rosace <- FilterData(rosace, key = key, na.rmax = 0.5)
```

Then we will impute the NA data either by K-Nearest Neighbor method or fill the NA with 0. 

```{r}
rosace <- ImputeData(rosace, key = key, impute.method = "knn", na.rmax = 0.5)
# rosace <- ImputeData(rosace, key = key, impute.method = "zero")
```

With a complete count matrix in the Assay object, we will normalize the data by either a list of wild-type variants or by the total count at the time point.

```{r}
rosace <- NormalizeData(rosace, key = key,
                        normalization.method = "wt", 
                        wt.var.names = c("_wt"), wt.rm = TRUE)
# rosace <- NormalizeData(rosace, key = key, normalization.method = "total")
```

After the Assay objects are all normalized, we can integrate three replicates into an Assays object stored in the "combined.assay" slot of the Rosace object.

```{r}
rosace <- IntegrateData(object = rosace, key = key)
GetAssaySetName(rosace)
```

#### Naive Method: simple linear regression (optional)

```{r}
rosace <- runSLR(rosace, name = key, type = "AssaySet")
rosace <- runSLR(rosace, name = paste(key, "1", sep = "_"), type = "Assay")
# rosace <- runSLR(rosace, name = paste(key, "2", sep = "_"), type = "Assay")
# rosace <- runSLR(rosace, name = paste(key, "3", sep = "_"), type = "Assay")
```

#### Process variants' meta data (provide your own function)

Provide your own function for parsing "hgvs" into position, mutation, wildtype, and type of mutation.

```{r}
library("dplyr")
colnames(rosace@var.data)
rosace@var.data <- rosace@var.data %>%
  mutate(tmp = substr(variants, 4, nchar(variants) - 1),
         position = as.numeric(gsub("[[:alpha:]]", "", tmp)),
         wildtype = substr(tmp, 1, 1),
         tmp = substr(tmp, 2, nchar(tmp)),
         mutation = gsub("[[:digit:]]", "", tmp)) %>%
  dplyr::select(-tmp)

func_map <- function(wt, mut) {
  if (nchar(wt) == 0) {
    return("NA")
  }
  
  if (wt == mut) {
    return("synonymous")
  } else if (mut == "del") {
    return("deletion")
  } else {
    return("missense")
  }
}

rosace@var.data <- rosace@var.data %>%
  rowwise() %>%
  mutate(type = func_map(wildtype, mutation)) %>%
  ungroup()
head(rosace@var.data)
```

#### Run Rosace

There are three ways to run Rosace model:
1) Provide no position or control column. 
The model would treat each variant independently but with shrinkage on the variance component.
2) Provide position column only.
In addition, the model would group variants together with the amino acid position information provided.
3) Provide both position and control column (recommended).
In addition, the model would group all control variants together into one position label.

For the purpose of this vignette, we've reduced the number of variants to 100 with brute force before running Rosace, since running on the full dataset might take an hour.

```{r message=FALSE}
# running on an Assay (one replicate)
rosace@assays$`1SM73_1`@norm.counts <- rosace@assays$`1SM73_1`@norm.counts[1:100, ]
rosace@assays$`1SM73_1`@norm.var.names <- rosace@assays$`1SM73_1`@norm.var.names[1:100]
rosace <- RunRosace(object = rosace,
                    name = "1SM73_1",
                    type = "Assay",
                    savedir = "../tests/results/stan/assay/", 
                    pos.col = "position", 
                    ctrl.col = "type",
                    ctrl.name = "synonymous",
                    install = FALSE)

# running on an AssaySet (all three replicates)
rosace@assay.sets$`1SM73`@raw.counts <- rosace@assay.sets$`1SM73`@raw.counts[1:100, ]
rosace@assay.sets$`1SM73`@combined.counts <- rosace@assay.sets$`1SM73`@combined.counts[1:100, ]
rosace@assay.sets$`1SM73`@var.names <- rosace@assay.sets$`1SM73`@var.names[1:100]
rosace <- RunRosace(object = rosace,
                    name = "1SM73",
                    type = "AssaySet",
                    savedir = "../tests/results/stan/assayset/",
                    pos.col = "position",
                    ctrl.col = "type", 
                    ctrl.name = "synonymous",
                    install = FALSE)
```

The Rosace results can be retrieved using the `OutputScore` function. First, check the name of your Rosace run:
```{r}
names(rosace@scores)
```

Then extract the scores data, which includes the variant information, functional score (`mean`), standard deviation (`sd`), and the local false sign discovery rate (`lfsr`) associated with the score.
```{r}
scores.data <- OutputScore(rosace, name = "1SM73_ROSACE")
head(scores.data)
```
The functional score represents the slope of the linear regression applied to normalized counts across time points, which serves as a measure of cell growth. A positive score indicates the mutation has a a gain of function (GOF) effect, while a negative score indicates a loss of function (LOF) effect. The Rosace model learns a distribution of scores and reports the mean for each variant. 

The `lfsr`, or local false sign rate, offers a Bayesian perspective for estimating uncertainty in the sign of the score. For a negative mean score, `lfsr` estimates the probability it could truly be positive, and vice versa. The below section illustrates how to use score and `lfsr` to identify LOF and GOF mutations. 

#### Interpret Rosace results

To have a more comprehensive understanding and clearer view of the score distribution, we've made available a precomputed object based on the complete OCT1 dataset. This may help you draw parallel to your own data. 

```{r}
# obtain the data 
data("oct1_rosace_scored")

# extract scores 
scores.data <- OutputScore(oct1_rosace_scored, name = "1SM73_ROSACE")
head(scores.data)
```

First, we can visualize the distribution of scores across mutation types with the `scoreDensity` function.
```{r}
scoreDensity(scores.data, 
             hist = FALSE,
             savedir = "../tests/results/stan/assayset_full/plot/", 
             name = "DensityPlot_1SM73")
```
For other visualizations including visualizing position-wise distributions, refer to the *Visualizing functional score results* vignette.


A common goal in DMS experiments is to determine which mutations cause a GOF or a LOF. One natural approach is to conduct hypothesis testing to check whether a score is significantly different from 0. To do this, we first order the variants by the absolute value of their score, then rank them by `lfsr` in ascending order. small values of `lfsr` indicate that we can be confident in the sign of the score. A variant with a large positive or negative score and `lfsr` close to 0 is likely a GOF or LOF, respectively.

```{r}
scores.data <- scores.data %>%
  arrange(desc(abs(mean)), lfsr)
head(scores.data)
```

You can choose a threshold for `lfsr` to classify mutations above it as neutral, and those below it as either GOF or LOF. The code below labels mutations into GOF, LOF, and neutral based on the score and `lfsr` < 0.05.

```{r}
scores.data <- scores.data %>%
  mutate(effect = case_when(
    mean > 0 & lfsr < 0.05 ~ "GOF",
    mean < 0 & lfsr < 0.05 ~ "LOF",
    TRUE ~ "neutral"
  ))

table(scores.data$effect)
```
Keep in mind that setting a threshold is a somewhat counter-Bayesian approach. The threshold should be adaptable, depending on the nature of the experiment and distribution of the data. You may be more or less conservative with thresholding based on the context and prior knowledge.

<div style="height: 200px;"></div>


